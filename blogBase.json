{"singlePage": [], "startSite": "10/27/2025", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "head": "", "indexScript": "", "indexStyle": "", "bottomText": "\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "exlink": {}, "needComment": 1, "allHead": "", "title": "\u56db\u5915\u7684\u535a\u5ba2\u5c0f\u7ad9", "subTitle": "\u4e00\u9897\u5feb\u4e50\u7801\u519c", "avatarUrl": "https://avatars.githubusercontent.com/u/52995168?v=4", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/si-xi-de-bo-ke-ce-shi.html", "labels": ["documentation"], "postTitle": "\u56db\u5915\u7684\u535a\u5ba2\u6d4b\u8bd5", "postUrl": "post/si-xi-de-bo-ke-ce-shi.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/1", "commentNum": 0, "wordCount": 17, "description": "# \u4e00\u7ea7\u6807\u9898\n## \u4e8c\u7ea7\u6807\u9898\n\n\n\u3002", "top": 0, "createdAt": 1761556471, "style": "", "script": "", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-10-27", "dateLabelColor": "#0969da"}, "P2": {"htmlDir": "docs/post/STM32-de-IWDG-pei-zhi.html", "labels": ["stm32"], "postTitle": "STM32\u7684IWDG\u914d\u7f6e", "postUrl": "post/STM32-de-IWDG-pei-zhi.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/2", "commentNum": 0, "wordCount": 345, "description": "# STM32cubemx\u7684IWDG\u914d\u7f6e\n\n<img width='997' height='675' alt='Image' src='https://github.com/user-attachments/assets/835715d8-c220-4ece-aa73-e887d318803b' />\n\n<img width='1141' height='546' alt='Image' src='https://github.com/user-attachments/assets/9aecc106-45a5-40e1-8c56-ff4fa311fe61' />\n\n\u4ee5\u4e0a\u8ff0\u4e3a\u4f8b\uff1aIWDG\u65f6\u949f\u9891\u7387\u4e3a32 000Hz\uff1b\n\u8fd9\u91cc\u8d85\u65f6\u65f6\u95f4\u4e3a32*\uff084095+1\uff09/32000 = 4.096s\u3002", "top": 0, "createdAt": 1761558157, "style": "", "script": "", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-10-27", "dateLabelColor": "#0969da"}, "P3": {"htmlDir": "docs/post/SBL-bu-zhen-ding-wei-yuan-li.html", "labels": ["knowledge"], "postTitle": "SBL\u5e03\u9635\u5b9a\u4f4d\u539f\u7406", "postUrl": "post/SBL-bu-zhen-ding-wei-yuan-li.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/3", "commentNum": 0, "wordCount": 1953, "description": "# \u56db\u6c34\u542c\u5668\u60c5\u51b5\n\n<img width='343' height='390' alt='Image' src='https://github.com/user-attachments/assets/866ff70c-a416-463e-9515-63093d10345b' />\n\n\u5982\u56fe1\u6240\u793a\u4e3aSBL\u7684\u5750\u6807\u7cfb\u7edf\uff0c1\u53f7\u6c34\u542c\u5668\u4f4d\u4e8e\u6c34\u542c\u5668\u57fa\u9635\u7684\u539f\u70b9\u5750\u6807\u4e3a(0,0,0)\u30012\u53f7\u6c34\u542c\u5668\u4f4d\u4e8ex\u5750\u6807\u8f74\u4e0a\u5750\u6807\u4e3a(A,0,0)\u30013\u53f7\u6c34\u542c\u5668\u4f4d\u4e8ey\u5750\u6807\u8f74\u4e0a\u5750\u6807\u4e3a(0,B,0)\u30014\u53f7\u6c34\u542c\u5668\u4f4d\u4e8ez\u5750\u6807\u8f74\u4e0a\u5750\u6807\u4e3a(0,0,C)\u3002", "top": 0, "createdAt": 1761620694, "style": "", "script": "<script>MathJax = {tex: {inlineMath: [[\"$\", \"$\"]]}};</script><script async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-10-28", "dateLabelColor": "#0969da"}, "P4": {"htmlDir": "docs/post/ren-shi-xian-xing-diao-pin-xin-hao-\uff08LFM\uff09.html", "labels": ["knowledge"], "postTitle": "\u8ba4\u8bc6\u7ebf\u6027\u8c03\u9891\u4fe1\u53f7\uff08LFM\uff09", "postUrl": "post/ren-shi-xian-xing-diao-pin-xin-hao-%EF%BC%88LFM%EF%BC%89.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/4", "commentNum": 0, "wordCount": 618, "description": "LFM\uff08\u7ebf\u6027\u8c03\u9891\uff09\u65e2\u53ef\u4ee5\u662f\u5b9e\u6570\uff08\u771f\u5b9e\u7269\u7406\u8f7d\u6ce2\uff09\u5f62\u5f0f\uff0c\u4e5f\u53ef\u4ee5\u7528\u590d\u6570\uff08\u89e3\u6790/\u57fa\u5e26\u7b49\u6548\uff09\u5f62\u5f0f\u8868\u793a\u2014\u2014\u53d6\u51b3\u4e8e\u4f60\u5728\u505a\u4ec0\u4e48\u3002", "top": 0, "createdAt": 1761872343, "style": "", "script": "<script>MathJax = {tex: {inlineMath: [[\"$\", \"$\"]]}};</script><script async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-10-31", "dateLabelColor": "#0969da"}, "P5": {"htmlDir": "docs/post/Matlab-zhong-de-TCP-he-chuan-kou-(uart)-fu-wu.html", "labels": ["matlab"], "postTitle": "Matlab\u4e2d\u7684TCP\u548c\u4e32\u53e3(uart)\u670d\u52a1", "postUrl": "post/Matlab-zhong-de-TCP-he-chuan-kou-%28uart%29-fu-wu.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/5", "commentNum": 0, "wordCount": 3708, "description": "\u4e00\u4e2a\u5f88\u7b80\u5355\u7684TCP\u4f8b\u5b50\u5982\u4e0b\uff1a\n```\nclc; clear; close all;\n\nt = tcpclient('192.168.1.120', 8080, 'Timeout', 5);\nPACK = 128;         % \u6bcf\u5e27\u957f\u5ea6\nIS_BIG_ENDIAN = false;\nsbl_dada = [0,0,0,0,0];\ndisp('\u7b49\u5f85\u4e8c\u8fdb\u5236\u5e27...');\nbuf = uint8([]);\ni = 0;\na = 1;\nh = 1.732;\n\nfigure(1)\n\nwhile true\n    n = t.NumBytesAvailable;\n    if n > 0\n        buf = read(t, n, 'uint8');\n    end\n    % \u591f\u4e00\u5e27\u5c31\u89e3\u6790\n    while numel(buf) == PACK\n        distance1_vals = typecast(buf(45:48), 'single');\n        distance2_vals = typecast(buf(49:52), 'single');\n        distance3_vals = typecast(buf(53:56), 'single');\n        distance = [distance1_vals distance2_vals distance3_vals];\n        body_position = distance_calculation_xyz(distance,a,h);\n        increase_vals = typecast(buf(117:120), 'single');\n        energy_vals = typecast(buf(121:124), 'single');\n        sbl_dada = [sbl_dada;distance1_vals distance2_vals distance3_vals increase_vals energy_vals];\n        fprintf('distance: %f  %f  %f  %f  %f\\n', distance1_vals, distance2_vals, distance3_vals, increase_vals, energy_vals);\n        buf = uint8([]);\n        i = i + 1;\n        subplot(3,2,[1 2]);\n        plot(i,distance1_vals,'b.',i,distance2_vals,'g.',i,distance3_vals,'r.');\n        hold on\n        ylim([11 20])\n        grid on\n        \n        subplot(3,2,3);\n        plot(i,increase_vals,'b.');\n        ylim([-500 300])\n        grid on\n        hold on\n        subplot(3,2,4);\n        plot(i,energy_vals,'b.');\n        ylim([0 20000000])\n        grid on\n        hold on\n\n        subplot(3,2,[5 6]);\n        plot(body_position(:,1),body_position(:,2),'r*-')\n        grid on\n        hold on\n    end\n\n    pause(0.005);\nend\n\nfunction body_position = distance_calculation_xyz(distance,a,h)\n% \u4e09\u6c34\u542c\u5668\u7b49\u8fb9\u4e09\u89d2\u5f62\u5e03\u9635\n% 1\u53f7\u6c34\u542c\u5668\u4f4d\u4e8eX\u8f74\u7684\u6b63\u534a\u8f74\uff0c\u5750\u6807\u4e3a(a,0,0)\uff0c\n% 2\u53f7\u6c34\u542c\u5668\u4f4d\u4e8eY\u8f74\u7684\u6b63\u534a\u8f74\uff0c\u5750\u6807\u4e3a(0,h,0)\uff0c\n% 3\u53f7\u6c34\u542c\u5668\u4f4d\u4e8eX\u8f74\u7684\u8d1f\u534a\u8f74\uff0c\u5750\u6807\u4e3a(-a,0,0)\u3002", "top": 0, "createdAt": 1762592125, "style": "", "script": "", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-11-08", "dateLabelColor": "#0969da"}, "P6": {"htmlDir": "docs/post/STM32CubeMX-de-ADC-pei-zhi-\uff08-yi-H7-wei-li-\uff09 .html", "labels": ["stm32"], "postTitle": "STM32CubeMX\u7684ADC\u914d\u7f6e\uff08\u4ee5H7\u4e3a\u4f8b\uff09 ", "postUrl": "post/STM32CubeMX-de-ADC-pei-zhi-%EF%BC%88-yi-H7-wei-li-%EF%BC%89%20.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/6", "commentNum": 0, "wordCount": 6155, "description": "# STM32CubeMX\u7684ADC\u914d\u7f6e\uff08\u4ee5H7\u4e3a\u4f8b\uff09\n\n\n\n## 1\u3001\u6253\u5f00ADC\u901a\u9053\n\n\u6839\u636e\u81ea\u5df1\u7684IO\u53e3\uff0c\u5230Analog\u4e2d\u9009\u62e9\u5bf9\u5e94\u7684ADCx\u548cINx;\n\n\n## 2\u3001ADC\u65f6\u949f\u914d\u7f6e\n\n\u9996\u5148\u5230**Clock Configuration**\u91cc\u5bf9ADC\u7684\u65f6\u949f\u8fdb\u884c\u914d\u7f6e\uff0c\u901a\u5e38\u6765\u8bf4\u4e3a**20~40MHz**\u4e4b\u95f4\u4e3a\u597d;\n\n\n## 3\u3001ADC\u8fdb\u884c\u521d\u59cb\u5316\u914d\u7f6e\n\n<u>***\u6253\u5f00Parameter Setting***</u>\n\n<u>***\u9ed8\u8ba4\u914d\u7f6e\u9700\u91cd\u70b9\u9009\u62e9`Resolution`\u3001`Conversion Data Management Mode`\u3001`External Trigger Conversion Source`\u3001`Rank` \u7b49\u9009\u9879***</u>\n\n### 3.1  ADCs_Conmon_Setting\u914d\u7f6e\u548c\u89e3\u91ca\n\n#### 3.1.1 Mode\u914d\u7f6e\n\n**\u63a8\u8350\u8bbe\u7f6e**\uff1aIndependent mode\n**\u89e3\u91ca**\uff1aH7 \u91cc\u6709\u591a\u4e2a ADC\uff08ADC1/2/3\uff09\uff0c\u53ef\u4ee5\u4e92\u76f8\u201c\u8054\u673a\u201d\u505a\u591a\u6a21\u5f0f\u91c7\u6837\uff0c\u4f60\u73b0\u5728\u53ea\u7528\u4e00\u4e2a ADC\uff0c\u5c31\u4fdd\u6301\u72ec\u7acb\u6a21\u5f0f\u5373\u53ef\u3002", "top": 0, "createdAt": 1763090895, "style": "", "script": "<script>MathJax = {tex: {inlineMath: [[\"$\", \"$\"]]}};</script><script async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"></script>", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-11-14", "dateLabelColor": "#0969da"}, "P7": {"htmlDir": "docs/post/STM32H7-de-ram\u3001rom-fen-qu-he-zhu-yi-shi-xiang.html", "labels": ["stm32"], "postTitle": "STM32H7\u7684ram\u3001rom\u5206\u533a\u548c\u6ce8\u610f\u4e8b\u9879", "postUrl": "post/STM32H7-de-ram%E3%80%81rom-fen-qu-he-zhu-yi-shi-xiang.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/7", "commentNum": 0, "wordCount": 3235, "description": "## 1\u3001STM32H7\u7cfb\u5217ram\u7684\u5206\u5e03\nram\uff08\u968f\u673a\u5b58\u53d6\u5b58\u50a8\u5668\uff0crandom access memory\uff09\uff0c\u4ee5STM32H743VIT6\u4e3a\u4f8b\uff0c\u4e3a1M RAM+2M Flash\u7684\u5b58\u50a8\u7a7a\u95f4\u3002", "top": 0, "createdAt": 1763635959, "style": "", "script": "", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2025-11-20", "dateLabelColor": "#0969da"}, "P8": {"htmlDir": "docs/post/STM32F103C8T6-chuan-kou-hei-xia-zi.html", "labels": ["stm32"], "postTitle": "STM32F103C8T6\u4e32\u53e3\u9ed1\u5323\u5b50", "postUrl": "post/STM32F103C8T6-chuan-kou-hei-xia-zi.html", "postSourceUrl": "https://github.com/sixiai/sixiai.github.io_old/issues/8", "commentNum": 0, "wordCount": 26545, "description": "# SD\u5361\u6570\u636e\u8bb0\u5f55\u7cfb\u7edf - \u5b8c\u6574\u603b\u7ed3 \n\n## \u4e00\u3001\u7cfb\u7edf\u529f\u80fd\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u4e32\u53e3\u53d1\u9001 '$new' \u2192 \u65b0\u5efa data00.txt \u2192 \u5f00\u59cb\u8bb0\u5f55\u6570\u636e        \u2502\n\u2502  \u4e32\u53e3\u53d1\u9001 '$new' \u2192 \u65b0\u5efa data01.txt \u2192 \u7ee7\u7eed\u8bb0\u5f55\u6570\u636e        \u2502\n\u2502  \u4e32\u53e3\u53d1\u9001 '$new' \u2192 \u65b0\u5efa data02.txt \u2192 ...                \u2502\n\u2502                                                         \u2502\n\u2502  \u5b9a\u65f6\u540c\u6b65\u6570\u636e\u5230SD\u5361\uff0c\u9632\u6b62\u65ad\u7535\u4e22\u5931                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## \u4e8c\u3001\u6587\u4ef6\u7ed3\u6784\n\n```\nProject/\n\u251c\u2500\u2500 Core/Inc/\n\u2502   \u251c\u2500\u2500 sd_spi.h\t\t\t     \u2190 SD\u521d\u59cb\u5316\u9a71\u52a8\n\u2502   \u251c\u2500\u2500 uart_driver.h      \u2190 \u4e32\u53e3\u9a71\u52a8\n\u2502   \u2514\u2500\u2500 sd_logger.h        \u2190 SD\u8bb0\u5f55\u5668\n\u251c\u2500\u2500 Core/Src/\n\u2502   \u251c\u2500\u2500 main.c             \u2190 \u4e3b\u7a0b\u5e8f\n\u2502   \u251c\u2500\u2500 sd_spi.c\t\t\t     \u2190 SD\u521d\u59cb\u5316\u9a71\u52a8\n\u2502   \u251c\u2500\u2500 uart_driver.c      \u2190 \u4e32\u53e3\u9a71\u52a8\n\u2502   \u251c\u2500\u2500 sd_logger.c        \u2190 SD\u8bb0\u5f55\u5668\n\u2502   \u2514\u2500\u2500 stm32f1xx_it.c     \u2190 \u4e2d\u65ad\u5904\u7406\n\u2514\u2500\u2500 FATFS/                 \n\u2502   \u251c\u2500\u2500 user_diskio.c\t\t\t \u2190 FatFs\u6587\u4ef6\u7cfb\u7edf\u6302\u8f7d\n```\n\n## \u4e09\u3001\u6838\u5fc3\u4ee3\u7801\n\n#### 3.1 sd_spi.h\n\n```c\n/* sd_spi.h */\n#ifndef __SD_SPI_H\n#define __SD_SPI_H\n\n#include 'main.h'\n#include 'spi.h'\n\n/* SD\u5361\u7c7b\u578b\u5b9a\u4e49 */\n#define SD_TYPE_ERR     0x00\n#define SD_TYPE_MMC     0x01\n#define SD_TYPE_V1      0x02\n#define SD_TYPE_V2      0x04\n#define SD_TYPE_V2HC    0x06\n\n/* SD\u5361\u6307\u4ee4 */\n#define CMD0    0       // \u590d\u4f4d\n#define CMD1    1       // \u521d\u59cb\u5316\n#define CMD8    8       // \u68c0\u67e5\u7535\u538b\u8303\u56f4\n#define CMD9    9       // \u8bfbCSD\n#define CMD10   10      // \u8bfbCID\n#define CMD12   12      // \u505c\u6b62\u4f20\u8f93\n#define CMD16   16      // \u8bbe\u7f6e\u5757\u5927\u5c0f\n#define CMD17   17      // \u8bfb\u5355\u5757\n#define CMD18   18      // \u8bfb\u591a\u5757\n#define CMD23   23      // \u9884\u64e6\u9664\n#define CMD24   24      // \u5199\u5355\u5757\n#define CMD25   25      // \u5199\u591a\u5757\n#define CMD41   41      // \u521d\u59cb\u5316(ACMD)\n#define CMD55   55      // APP\u547d\u4ee4\u524d\u7f00\n#define CMD58   58      // \u8bfbOCR\n\n/* \u51fd\u6570\u58f0\u660e */\nuint8_t SD_Init(void);\nuint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);\nuint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);\nuint32_t SD_GetSectorCount(void);\n\nextern uint8_t SD_Type;\n\n#endif\n\n```\n\n#### 3.2 sd_spi.c\n\n```c\n/* sd_spi.c */\n#include 'sd_spi.h'\n\nuint8_t SD_Type = 0;\n\n/* CS\u5f15\u811a\u63a7\u5236 */\n#define SD_CS_LOW()     HAL_GPIO_WritePin(CD_CS_GPIO_Port, CD_CS_Pin, GPIO_PIN_RESET)\n#define SD_CS_HIGH()    HAL_GPIO_WritePin(CD_CS_GPIO_Port, CD_CS_Pin, GPIO_PIN_SET)\n\n/* SPI\u8bfb\u5199\u4e00\u4e2a\u5b57\u8282 */\nstatic uint8_t SD_SPI_ReadWriteByte(uint8_t data)\n{\n    uint8_t rxData;\n    HAL_SPI_TransmitReceive(&hspi1, &data, &rxData, 1, 100);\n    return rxData;\n}\n\n/* \u8bbe\u7f6eSPI\u901f\u5ea6 */\nstatic void SD_SPI_SetSpeed(uint8_t speed)\n{\n    __HAL_SPI_DISABLE(&hspi1);\n    if(speed == 0) {\n        hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; // \u4f4e\u901f\n    } else {\n        hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;   // \u9ad8\u901f\n    }\n    HAL_SPI_Init(&hspi1);\n    __HAL_SPI_ENABLE(&hspi1);\n}\n\n/* \u7b49\u5f85SD\u5361\u5c31\u7eea */\nstatic uint8_t SD_WaitReady(void)\n{\n    uint32_t t = 0;\n    do {\n        if(SD_SPI_ReadWriteByte(0xFF) == 0xFF) return 0;\n        t++;\n    } while(t < 0xFFFFFF);\n    return 1;\n}\n\n/* \u53d1\u9001\u547d\u4ee4 */\nstatic uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg, uint8_t crc)\n{\n    uint8_t r1;\n    uint8_t retry = 0;\n    \n    SD_CS_HIGH();\n    SD_SPI_ReadWriteByte(0xFF);\n    SD_CS_LOW();\n    \n    if(SD_WaitReady()) return 0xFF;\n    \n    SD_SPI_ReadWriteByte(cmd | 0x40);\n    SD_SPI_ReadWriteByte(arg >> 24);\n    SD_SPI_ReadWriteByte(arg >> 16);\n    SD_SPI_ReadWriteByte(arg >> 8);\n    SD_SPI_ReadWriteByte(arg);\n    SD_SPI_ReadWriteByte(crc);\n    \n    if(cmd == CMD12) SD_SPI_ReadWriteByte(0xFF);\n    \n    retry = 0x1F;\n    do {\n        r1 = SD_SPI_ReadWriteByte(0xFF);\n    } while((r1 & 0x80) && retry--);\n    \n    return r1;\n}\n\n/* SD\u5361\u521d\u59cb\u5316 */\nuint8_t SD_Init(void)\n{\n    uint8_t r1;\n    uint16_t retry;\n    uint8_t buf[4];\n    \n    SD_SPI_SetSpeed(0);  // \u4f4e\u901f\u6a21\u5f0f\n    \n    SD_CS_HIGH();\n    for(int i = 0; i < 10; i++) {\n        SD_SPI_ReadWriteByte(0xFF);  // \u53d1\u9001\u81f3\u5c1174\u4e2a\u65f6\u949f\n    }\n    \n    retry = 20;\n    do {\n        r1 = SD_SendCmd(CMD0, 0, 0x95);\n    } while((r1 != 0x01) && retry--);\n    \n    if(r1 == 0x01) {\n        if(SD_SendCmd(CMD8, 0x1AA, 0x87) == 1) {\n            for(int i = 0; i < 4; i++) {\n                buf[i] = SD_SPI_ReadWriteByte(0xFF);\n            }\n            if(buf[2] == 0x01 && buf[3] == 0xAA) {\n                retry = 0xFFFE;\n                do {\n                    SD_SendCmd(CMD55, 0, 0x01);\n                    r1 = SD_SendCmd(CMD41, 0x40000000, 0x01);\n                } while(r1 && retry--);\n                \n                if(retry && SD_SendCmd(CMD58, 0, 0x01) == 0) {\n                    for(int i = 0; i < 4; i++) {\n                        buf[i] = SD_SPI_ReadWriteByte(0xFF);\n                    }\n                    if(buf[0] & 0x40) {\n                        SD_Type = SD_TYPE_V2HC;\n                    } else {\n                        SD_Type = SD_TYPE_V2;\n                    }\n                }\n            }\n        } else {\n            SD_SendCmd(CMD55, 0, 0x01);\n            r1 = SD_SendCmd(CMD41, 0, 0x01);\n            if(r1 <= 1) {\n                SD_Type = SD_TYPE_V1;\n                retry = 0xFFFE;\n                do {\n                    SD_SendCmd(CMD55, 0, 0x01);\n                    r1 = SD_SendCmd(CMD41, 0, 0x01);\n                } while(r1 && retry--);\n            } else {\n                SD_Type = SD_TYPE_MMC;\n                retry = 0xFFFE;\n                do {\n                    r1 = SD_SendCmd(CMD1, 0, 0x01);\n                } while(r1 && retry--);\n            }\n            if(retry == 0 || SD_SendCmd(CMD16, 512, 0x01) != 0) {\n                SD_Type = SD_TYPE_ERR;\n            }\n        }\n    }\n    \n    SD_CS_HIGH();\n    SD_SPI_SetSpeed(1);  // \u9ad8\u901f\u6a21\u5f0f\n    \n    if(SD_Type) return 0;\n    return 1;\n}\n\n/* \u8bfb\u53d6\u6307\u5b9a\u6247\u533a */\nuint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt)\n{\n    uint8_t r1;\n    \n    if(SD_Type != SD_TYPE_V2HC) sector <<= 9;\n    \n    if(cnt == 1) {\n        r1 = SD_SendCmd(CMD17, sector, 0x01);\n        if(r1 == 0) {\n            uint16_t retry = 0xFFFE;\n            do {\n                r1 = SD_SPI_ReadWriteByte(0xFF);\n                if(r1 == 0xFE) break;\n            } while(retry--);\n            \n            if(r1 == 0xFE) {\n                for(int i = 0; i < 512; i++) {\n                    buf[i] = SD_SPI_ReadWriteByte(0xFF);\n                }\n                SD_SPI_ReadWriteByte(0xFF);\n                SD_SPI_ReadWriteByte(0xFF);\n                r1 = 0;\n            } else {\n                r1 = 1;\n            }\n        }\n    } else {\n        r1 = SD_SendCmd(CMD18, sector, 0x01);\n        if(r1 == 0) {\n            do {\n                uint16_t retry = 0xFFFE;\n                do {\n                    r1 = SD_SPI_ReadWriteByte(0xFF);\n                    if(r1 == 0xFE) break;\n                } while(retry--);\n                \n                if(r1 != 0xFE) break;\n                \n                for(int i = 0; i < 512; i++) {\n                    *buf++ = SD_SPI_ReadWriteByte(0xFF);\n                }\n                SD_SPI_ReadWriteByte(0xFF);\n                SD_SPI_ReadWriteByte(0xFF);\n            } while(--cnt);\n            SD_SendCmd(CMD12, 0, 0x01);\n        }\n        r1 = cnt ? 1 : 0;\n    }\n    \n    SD_CS_HIGH();\n    return r1;\n}\n\n/* \u5199\u5165\u6307\u5b9a\u6247\u533a */\nuint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt)\n{\n    uint8_t r1;\n    \n    if(SD_Type != SD_TYPE_V2HC) sector <<= 9;\n    \n    if(cnt == 1) {\n        r1 = SD_SendCmd(CMD24, sector, 0x01);\n        if(r1 == 0) {\n            if(SD_WaitReady() == 0) {\n                SD_SPI_ReadWriteByte(0xFE);\n                for(int i = 0; i < 512; i++) {\n                    SD_SPI_ReadWriteByte(buf[i]);\n                }\n                SD_SPI_ReadWriteByte(0xFF);\n                SD_SPI_ReadWriteByte(0xFF);\n                \n                r1 = SD_SPI_ReadWriteByte(0xFF);\n                if((r1 & 0x1F) == 0x05) {\n                    r1 = 0;\n                    uint32_t retry = 0xFFFFFF;\n                    while(SD_SPI_ReadWriteByte(0xFF) == 0 && retry--);\n                    if(retry == 0) r1 = 1;\n                } else {\n                    r1 = 1;\n                }\n            } else {\n                r1 = 1;\n            }\n        }\n    } else {\n        if(SD_Type != SD_TYPE_MMC) {\n            SD_SendCmd(CMD55, 0, 0x01);\n            SD_SendCmd(CMD23, cnt, 0x01);\n        }\n        r1 = SD_SendCmd(CMD25, sector, 0x01);\n        if(r1 == 0) {\n            do {\n                if(SD_WaitReady()) { r1 = 1; break; }\n                SD_SPI_ReadWriteByte(0xFC);\n                for(int i = 0; i < 512; i++) {\n                    SD_SPI_ReadWriteByte(*buf++);\n                }\n                SD_SPI_ReadWriteByte(0xFF);\n                SD_SPI_ReadWriteByte(0xFF);\n                \n                r1 = SD_SPI_ReadWriteByte(0xFF);\n                if((r1 & 0x1F) != 0x05) { r1 = 1; break; }\n            } while(--cnt);\n            \n            SD_SPI_ReadWriteByte(0xFD);\n            r1 = cnt ? 1 : 0;\n        }\n    }\n    \n    SD_CS_HIGH();\n    return r1;\n}\n\n/* \u83b7\u53d6\u6247\u533a\u6570\u91cf */\nuint32_t SD_GetSectorCount(void)\n{\n    uint8_t csd[16];\n    uint32_t capacity;\n    uint8_t n;\n    uint16_t csize;\n    \n    if(SD_SendCmd(CMD9, 0, 0x01) == 0) {\n        uint16_t retry = 0xFFFE;\n        while(SD_SPI_ReadWriteByte(0xFF) != 0xFE && retry--);\n        \n        if(retry) {\n            for(int i = 0; i < 16; i++) {\n                csd[i] = SD_SPI_ReadWriteByte(0xFF);\n            }\n            SD_SPI_ReadWriteByte(0xFF);\n            SD_SPI_ReadWriteByte(0xFF);\n            \n            if((csd[0] & 0xC0) == 0x40) {  // V2.0\n                csize = csd[9] + ((uint16_t)csd[8] << 8) + ((uint32_t)(csd[7] & 0x3F) << 16) + 1;\n                capacity = csize << 10;\n            } else {  // V1.0\n                n = (csd[5] & 0x0F) + ((csd[10] & 0x80) >> 7) + ((csd[9] & 0x03) << 1) + 2;\n                csize = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 0x03) << 10) + 1;\n                capacity = (uint32_t)csize << (n - 9);\n            }\n            SD_CS_HIGH();\n            return capacity;\n        }\n    }\n    SD_CS_HIGH();\n    return 0;\n}\n\n```\n\n#### 3.3 user_diskio.c\n\n```c\n/* USER CODE BEGIN Header */\n/**\n ******************************************************************************\n  * @file    user_diskio.c\n  * @brief   This file includes a diskio driver skeleton to be completed by the user.\n  ******************************************************************************\n  * @attention\n  *\n  * Copyright (c) 2026 STMicroelectronics.\n  * All rights reserved.\n  *\n  * This software is licensed under terms that can be found in the LICENSE file\n  * in the root directory of this software component.\n  * If no LICENSE file comes with this software, it is provided AS-IS.\n  *\n  ******************************************************************************\n  */\n /* USER CODE END Header */\n\n#ifdef USE_OBSOLETE_USER_CODE_SECTION_0\n/*\n * Warning: the user section 0 is no more in use (starting from CubeMx version 4.16.0)\n * To be suppressed in the future.\n * Kept to ensure backward compatibility with previous CubeMx versions when\n * migrating projects.\n * User code previously added there should be copied in the new user sections before\n * the section contents can be deleted.\n */\n/* USER CODE BEGIN 0 */\n/* USER CODE END 0 */\n#endif\n\n/* USER CODE BEGIN DECL */\n\n/* Includes ------------------------------------------------------------------*/\n#include <string.h>\n#include 'ff_gen_drv.h'\n\n\n#include 'sd_spi.h'\n/* Private typedef -----------------------------------------------------------*/\n/* Private define ------------------------------------------------------------*/\n\n/* Private variables ---------------------------------------------------------*/\n/* Disk status */\nstatic volatile DSTATUS Stat = STA_NOINIT;\n\n/* USER CODE END DECL */\n\n/* Private function prototypes -----------------------------------------------*/\nDSTATUS USER_initialize (BYTE pdrv);\nDSTATUS USER_status (BYTE pdrv);\nDRESULT USER_read (BYTE pdrv, BYTE *buff, DWORD sector, UINT count);\n#if _USE_WRITE == 1\n  DRESULT USER_write (BYTE pdrv, const BYTE *buff, DWORD sector, UINT count);\n#endif /* _USE_WRITE == 1 */\n#if _USE_IOCTL == 1\n  DRESULT USER_ioctl (BYTE pdrv, BYTE cmd, void *buff);\n#endif /* _USE_IOCTL == 1 */\n\nDiskio_drvTypeDef  USER_Driver =\n{\n  USER_initialize,\n  USER_status,\n  USER_read,\n#if  _USE_WRITE\n  USER_write,\n#endif  /* _USE_WRITE == 1 */\n#if  _USE_IOCTL == 1\n  USER_ioctl,\n#endif /* _USE_IOCTL == 1 */\n};\n\n/* Private functions ---------------------------------------------------------*/\n\n/**\n  * @brief  Initializes a Drive\n  * @param  pdrv: Physical drive number (0..)\n  * @retval DSTATUS: Operation status\n  */\nDSTATUS USER_initialize (\n\tBYTE pdrv           /* Physical drive nmuber to identify the drive */\n)\n{\n  /* USER CODE BEGIN INIT */\n//    Stat = STA_NOINIT;\n//    return Stat;\n\t\tuint8_t res;\n    res = SD_Init();\n    if(res == 0) {\n        Stat &= ~STA_NOINIT;\n    } else {\n        Stat = STA_NOINIT;\n    }\n    return Stat;\n  /* USER CODE END INIT */\n}\n\n/**\n  * @brief  Gets Disk Status\n  * @param  pdrv: Physical drive number (0..)\n  * @retval DSTATUS: Operation status\n  */\nDSTATUS USER_status (\n\tBYTE pdrv       /* Physical drive number to identify the drive */\n)\n{\n  /* USER CODE BEGIN STATUS */\n//    Stat = STA_NOINIT;\n//    return Stat;\n\t\treturn Stat;\n  /* USER CODE END STATUS */\n}\n\n/**\n  * @brief  Reads Sector(s)\n  * @param  pdrv: Physical drive number (0..)\n  * @param  *buff: Data buffer to store read data\n  * @param  sector: Sector address (LBA)\n  * @param  count: Number of sectors to read (1..128)\n  * @retval DRESULT: Operation result\n  */\nDRESULT USER_read (\n\tBYTE pdrv,      /* Physical drive nmuber to identify the drive */\n\tBYTE *buff,     /* Data buffer to store read data */\n\tDWORD sector,   /* Sector address in LBA */\n\tUINT count      /* Number of sectors to read */\n)\n{\n  /* USER CODE BEGIN READ */\n//    return RES_OK;\n    uint8_t res;\n    res = SD_ReadDisk(buff, sector, count);\n    if(res == 0) {\n        return RES_OK;\n    }\n    return RES_ERROR;\n  /* USER CODE END READ */\n}\n\n/**\n  * @brief  Writes Sector(s)\n  * @param  pdrv: Physical drive number (0..)\n  * @param  *buff: Data to be written\n  * @param  sector: Sector address (LBA)\n  * @param  count: Number of sectors to write (1..128)\n  * @retval DRESULT: Operation result\n  */\n#if _USE_WRITE == 1\nDRESULT USER_write (\n\tBYTE pdrv,          /* Physical drive nmuber to identify the drive */\n\tconst BYTE *buff,   /* Data to be written */\n\tDWORD sector,       /* Sector address in LBA */\n\tUINT count          /* Number of sectors to write */\n)\n{\n  /* USER CODE BEGIN WRITE */\n  /* USER CODE HERE */\n//    return RES_OK;\n    uint8_t res;\n    res = SD_WriteDisk((uint8_t *)buff, sector, count);\n    if(res == 0) {\n        return RES_OK;\n    }\n    return RES_ERROR;\n  /* USER CODE END WRITE */\n}\n#endif /* _USE_WRITE == 1 */\n\n/**\n  * @brief  I/O control operation\n  * @param  pdrv: Physical drive number (0..)\n  * @param  cmd: Control code\n  * @param  *buff: Buffer to send/receive control data\n  * @retval DRESULT: Operation result\n  */\n#if _USE_IOCTL == 1\nDRESULT USER_ioctl (\n\tBYTE pdrv,      /* Physical drive nmuber (0..) */\n\tBYTE cmd,       /* Control code */\n\tvoid *buff      /* Buffer to send/receive control data */\n)\n{\n  /* USER CODE BEGIN IOCTL */\n//    DRESULT res = RES_ERROR;\n//    return res;\n    DRESULT res = RES_ERROR;\n    \n    switch(cmd) {\n        case CTRL_SYNC:\n            res = RES_OK;\n            break;\n        case GET_SECTOR_COUNT:\n            *(DWORD *)buff = SD_GetSectorCount();\n            res = RES_OK;\n            break;\n        case GET_SECTOR_SIZE:\n            *(WORD *)buff = 512;\n            res = RES_OK;\n            break;\n        case GET_BLOCK_SIZE:\n            *(DWORD *)buff = 8;\n            res = RES_OK;\n            break;\n        default:\n            res = RES_PARERR;\n            break;\n    }\n    return res;\n  /* USER CODE END IOCTL */\n}\n#endif /* _USE_IOCTL == 1 */\n\n\n```\n\n\n\n#### 3.4 uart_driver.h\n\n```c\n#ifndef __UART_DRIVER_H\n#define __UART_DRIVER_H\n\n#include 'main.h'\n#include 'usart.h'\n#include 'dma.h'\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n\n#define UART_DMA_RX_BUFFER_SIZE     512\n#define UART_DATA_BUFFER_SIZE       1024\n#define UART_TX_BUFFER_SIZE         256\n#define CMD_NEW_FILE                '$new'\n\ntypedef enum {\n    RX_TYPE_NONE = 0,\n    RX_TYPE_CMD_NEW,\n    RX_TYPE_DATA\n} RxDataType_t;\n\ntypedef struct {\n    uint8_t     dma_rx_buffer[UART_DMA_RX_BUFFER_SIZE];\n    uint8_t     data_buffer[UART_DATA_BUFFER_SIZE];\n    char        tx_buffer[UART_TX_BUFFER_SIZE];\n    volatile uint16_t   data_len;\n    volatile uint8_t    rx_complete;\n    RxDataType_t        rx_type;\n    UART_HandleTypeDef  *huart;\n    DMA_HandleTypeDef   *hdma_rx;\n} UART_Driver_t;\n\nextern UART_Driver_t uart1_driver;\n\nvoid UART_Driver_Init(UART_Driver_t *driver, UART_HandleTypeDef *huart, DMA_HandleTypeDef *hdma_rx);\nvoid UART_Driver_StartReceive(UART_Driver_t *driver);\nvoid UART_Driver_IDLE_Handler(UART_Driver_t *driver);\nuint8_t UART_Driver_IsRxComplete(UART_Driver_t *driver);\nRxDataType_t UART_Driver_GetRxType(UART_Driver_t *driver);\nvoid UART_Driver_GetData(UART_Driver_t *driver, uint8_t **data, uint16_t *len);\nvoid UART_Driver_ClearRxFlag(UART_Driver_t *driver);\nvoid UART_Driver_Printf(UART_Driver_t *driver, const char *format, ...);\n\n#endif\n\n```\n\n#### 3.5 uart_driver.c\n\n```c\n#include 'uart_driver.h'\n\nUART_Driver_t uart1_driver;\n\nstatic RxDataType_t Parse_RxData(uint8_t *data, uint16_t len)\n{\n    if(len >= strlen(CMD_NEW_FILE)) {\n        if(strncmp((char *)data, CMD_NEW_FILE, strlen(CMD_NEW_FILE)) == 0) {\n            return RX_TYPE_CMD_NEW;\n        }\n    }\n    return RX_TYPE_DATA;\n}\n\nvoid UART_Driver_Init(UART_Driver_t *driver, UART_HandleTypeDef *huart, DMA_HandleTypeDef *hdma_rx)\n{\n    driver->huart = huart;\n    driver->hdma_rx = hdma_rx;\n    memset(driver->dma_rx_buffer, 0, UART_DMA_RX_BUFFER_SIZE);\n    memset(driver->data_buffer, 0, UART_DATA_BUFFER_SIZE);\n    driver->data_len = 0;\n    driver->rx_complete = 0;\n    driver->rx_type = RX_TYPE_NONE;\n}\n\nvoid UART_Driver_StartReceive(UART_Driver_t *driver)\n{\n    __HAL_UART_CLEAR_IDLEFLAG(driver->huart);\n    __HAL_UART_ENABLE_IT(driver->huart, UART_IT_IDLE);\n    HAL_UART_Receive_DMA(driver->huart, driver->dma_rx_buffer, UART_DMA_RX_BUFFER_SIZE);\n}\n\nvoid UART_Driver_IDLE_Handler(UART_Driver_t *driver)\n{\n    uint16_t recv_len;\n    \n    if(__HAL_UART_GET_FLAG(driver->huart, UART_FLAG_IDLE) != RESET)\n    {\n        __HAL_UART_CLEAR_IDLEFLAG(driver->huart);\n        HAL_UART_DMAStop(driver->huart);\n        \n        recv_len = UART_DMA_RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(driver->hdma_rx);\n        \n        if(recv_len > 0 && recv_len <= UART_DATA_BUFFER_SIZE)\n        {\n            memcpy(driver->data_buffer, driver->dma_rx_buffer, recv_len);\n            driver->data_len = recv_len;\n            driver->rx_type = Parse_RxData(driver->data_buffer, recv_len);\n            driver->rx_complete = 1;\n        }\n        \n        memset(driver->dma_rx_buffer, 0, UART_DMA_RX_BUFFER_SIZE);\n        HAL_UART_Receive_DMA(driver->huart, driver->dma_rx_buffer, UART_DMA_RX_BUFFER_SIZE);\n    }\n}\n\nuint8_t UART_Driver_IsRxComplete(UART_Driver_t *driver) { return driver->rx_complete; }\nRxDataType_t UART_Driver_GetRxType(UART_Driver_t *driver) { return driver->rx_type; }\n\nvoid UART_Driver_GetData(UART_Driver_t *driver, uint8_t **data, uint16_t *len)\n{\n    *data = driver->data_buffer;\n    *len = driver->data_len;\n}\n\nvoid UART_Driver_ClearRxFlag(UART_Driver_t *driver)\n{\n    driver->rx_complete = 0;\n    driver->data_len = 0;\n    driver->rx_type = RX_TYPE_NONE;\n}\n\nvoid UART_Driver_Printf(UART_Driver_t *driver, const char *format, ...)\n{\n    uint16_t len;\n    va_list args;\n    va_start(args, format);\n    len = vsprintf(driver->tx_buffer, format, args);\n    va_end(args);\n    HAL_UART_Transmit(driver->huart, (uint8_t *)driver->tx_buffer, len, 1000);\n}\n\n```\n\n#### 3.6 sd_logger.h\n\n```c\n#ifndef __SD_LOGGER_H\n#define __SD_LOGGER_H\n\n#include 'main.h'\n#include 'fatfs.h'\n#include <string.h>\n#include <stdio.h>\n\n#define FILE_NAME_PREFIX        'data'\n#define FILE_NAME_EXTENSION     '.txt'\n#define FILE_INDEX_MAX          99\n#define SYNC_AFTER_BYTES        512\n\ntypedef enum {\n    LOGGER_IDLE = 0,\n    LOGGER_RECORDING\n} LoggerState_t;\n\ntypedef struct {\n    FATFS       fs;\n    FIL         file;\n    char        filename[32];\n    uint8_t     file_index;\n    LoggerState_t state;\n    uint8_t     sd_mounted;\n    uint32_t    total_bytes;\n    uint32_t    unsync_bytes;\n} SD_Logger_t;\n\nextern SD_Logger_t sd_logger;\n\nuint8_t SD_Logger_Init(void);\nuint8_t SD_Logger_NewFile(void);\nuint16_t SD_Logger_WriteData(uint8_t *data, uint16_t len);\nuint8_t SD_Logger_Sync(void);\nLoggerState_t SD_Logger_GetState(void);\nconst char* SD_Logger_GetFilename(void);\nuint8_t SD_Logger_GetFileIndex(void);\nuint32_t SD_Logger_GetTotalBytes(void);\n\n#endif\n\n```\n\n#### 3.7 sd_logger.c\n\n```c\n#include 'sd_logger.h'\n\nSD_Logger_t sd_logger;\n\nstatic void Generate_Filename(uint8_t index, char *filename)\n{\n    sprintf(filename, '%s%02d%s', FILE_NAME_PREFIX, index, FILE_NAME_EXTENSION);\n}\n\nstatic uint8_t File_Exists(const char *filename)\n{\n    FILINFO fno;\n    return (f_stat(filename, &fno) == FR_OK) ? 1 : 0;\n}\n\nstatic uint8_t Find_Next_FileIndex(void)\n{\n    char filename[32];\n    for(uint8_t i = 0; i <= FILE_INDEX_MAX; i++) {\n        Generate_Filename(i, filename);\n        if(!File_Exists(filename)) return i;\n    }\n    return 0;\n}\n\nuint8_t SD_Logger_Init(void)\n{\n    FRESULT fres;\n    memset(&sd_logger, 0, sizeof(SD_Logger_t));\n    \n    fres = f_mount(&sd_logger.fs, '', 1);\n    if(fres != FR_OK) return (uint8_t)fres;\n    \n    sd_logger.sd_mounted = 1;\n    sd_logger.file_index = Find_Next_FileIndex();\n    return 0;\n}\n\nuint8_t SD_Logger_NewFile(void)\n{\n    FRESULT fres;\n    if(!sd_logger.sd_mounted) return 1;\n    \n    /* \u5173\u95ed\u65e7\u6587\u4ef6 */\n    if(sd_logger.state == LOGGER_RECORDING) {\n        f_sync(&sd_logger.file);\n        f_close(&sd_logger.file);\n    }\n    \n    /* \u521b\u5efa\u65b0\u6587\u4ef6 */\n    Generate_Filename(sd_logger.file_index, sd_logger.filename);\n    fres = f_open(&sd_logger.file, sd_logger.filename, FA_CREATE_ALWAYS | FA_WRITE);\n    if(fres != FR_OK) return (uint8_t)fres;\n    \n    sd_logger.state = LOGGER_RECORDING;\n    sd_logger.total_bytes = 0;\n    sd_logger.unsync_bytes = 0;\n    \n    sd_logger.file_index++;\n    if(sd_logger.file_index > FILE_INDEX_MAX) sd_logger.file_index = 0;\n    \n    return 0;\n}\n\nuint16_t SD_Logger_WriteData(uint8_t *data, uint16_t len)\n{\n    UINT bw = 0;\n    if(sd_logger.state != LOGGER_RECORDING) return 0;\n    \n    if(f_write(&sd_logger.file, data, len, &bw) != FR_OK) return 0;\n    \n    sd_logger.total_bytes += bw;\n    sd_logger.unsync_bytes += bw;\n    \n    /* \u81ea\u52a8\u540c\u6b65\u4fdd\u62a4 */\n    if(sd_logger.unsync_bytes >= SYNC_AFTER_BYTES) {\n        f_sync(&sd_logger.file);\n        sd_logger.unsync_bytes = 0;\n    }\n    \n    return (uint16_t)bw;\n}\n\nuint8_t SD_Logger_Sync(void)\n{\n    if(sd_logger.state != LOGGER_RECORDING) return 0;\n    sd_logger.unsync_bytes = 0;\n    return (uint8_t)f_sync(&sd_logger.file);\n}\n\nLoggerState_t SD_Logger_GetState(void) { return sd_logger.state; }\nconst char* SD_Logger_GetFilename(void) { return sd_logger.filename; }\nuint8_t SD_Logger_GetFileIndex(void) { return sd_logger.file_index; }\nuint32_t SD_Logger_GetTotalBytes(void) { return sd_logger.total_bytes; }\n\n```\n\n#### 3.8 main.c\n\n```c\n#include 'main.h'\n#include 'dma.h'\n#include 'fatfs.h'\n#include 'spi.h'\n#include 'tim.h'\n#include 'usart.h'\n#include 'gpio.h'\n#include 'uart_driver.h'\n#include 'sd_logger.h'\n\nvolatile uint8_t tim2_flag = 0;\nvolatile uint16_t tim2_counter = 0;\n\nint main(void)\n{\n    HAL_Init();\n    SystemClock_Config();\n    MX_GPIO_Init();\n    MX_DMA_Init();\n    MX_SPI1_Init();\n    MX_TIM2_Init();\n    MX_USART1_UART_Init();\n    MX_FATFS_Init();\n    \n    UART_Driver_Init(&uart1_driver, &huart1, &hdma_usart1_rx);\n    \n    if(SD_Logger_Init() == 0) {\n        UART_Driver_Printf(&uart1_driver, 'SD Ready! Next: data%02d.txt\\r\\n', SD_Logger_GetFileIndex());\n    }\n    \n    UART_Driver_StartReceive(&uart1_driver);\n    HAL_TIM_Base_Start_IT(&htim2);\n    \n    UART_Driver_Printf(&uart1_driver, 'Send '$new' to start recording\\r\\n');\n    \n    while(1)\n    {\n        /* \u5b9a\u65f6\u4efb\u52a1 */\n        if(tim2_flag)\n        {\n            tim2_flag = 0;\n            \n            if(tim2_counter % 100 == 0) {  /* 1\u79d2 */\n                HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);\n            }\n            \n            if(tim2_counter % 200 == 0) {  /* 2\u79d2\u540c\u6b65 */\n                if(SD_Logger_GetState() == LOGGER_RECORDING) {\n                    SD_Logger_Sync();\n                }\n            }\n            \n            if(tim2_counter >= 10000) tim2_counter = 0;\n            tim2_counter++;\n        }\n        \n        /* \u4e32\u53e3\u5904\u7406 */\n        if(UART_Driver_IsRxComplete(&uart1_driver))\n        {\n            RxDataType_t rx_type = UART_Driver_GetRxType(&uart1_driver);\n            \n            if(rx_type == RX_TYPE_CMD_NEW) {\n                if(SD_Logger_NewFile() == 0) {\n                    UART_Driver_Printf(&uart1_driver, 'Created: %s\\r\\n', SD_Logger_GetFilename());\n                }\n            }\n            else if(rx_type == RX_TYPE_DATA) {\n                if(SD_Logger_GetState() == LOGGER_RECORDING) {\n                    uint8_t *data; uint16_t len;\n                    UART_Driver_GetData(&uart1_driver, &data, &len);\n                    SD_Logger_WriteData(data, len);\n                }\n            }\n            \n            UART_Driver_ClearRxFlag(&uart1_driver);\n        }\n    }\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n    if(htim->Instance == TIM2) tim2_flag = 1;\n}\n\n```\n\n#### 3.9 stm32f1xx_it.c\uff08\u4e2d\u65ad\u90e8\u5206\uff09\n\n```c\n#include 'uart_driver.h'\n\nvoid USART1_IRQHandler(void)\n{\n    UART_Driver_IDLE_Handler(&uart1_driver);\n    HAL_UART_IRQHandler(&huart1);\n}\n\n```\n\n### \u56db\u3001\u65ad\u7535\u4fdd\u62a4\u673a\u5236\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           \u53cc\u91cd\u4fdd\u62a4                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. \u5199\u5165\u4fdd\u62a4: \u6bcf512\u5b57\u8282\u81ea\u52a8\u540c\u6b65           \u2502\n\u2502 2. \u5b9a\u65f6\u4fdd\u62a4: \u6bcf2\u79d2\u5f3a\u5236\u540c\u6b65               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 \u65ad\u7535\u6700\u5927\u635f\u5931: \u2264512\u5b57\u8282                   \u2502\n\u2502 \u6587\u4ef6\u7cfb\u7edf\u98ce\u9669: \u4f4e                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### \u4e94\u3001\u4f7f\u7528\u6d41\u7a0b\n\n```\n\u4e0a\u7535 \u2192 SD\u5361\u521d\u59cb\u5316 \u2192 \u7b49\u5f85\u547d\u4ee4\n         \u2193\n\u53d1\u9001 '$new' \u2192 \u521b\u5efa data00.txt \u2192 \u8bb0\u5f55\u6570\u636e\n         \u2193\n\u53d1\u9001 '$new' \u2192 \u5173\u95ed\u65e7\u6587\u4ef6 \u2192 \u521b\u5efa data01.txt\n         \u2193\n      \u4f9d\u6b21\u9012\u589e...\n```\n\n### \u516d\u3001\u4e32\u53e3\u6d4b\u8bd5\n\n```\nSD Ready! Next: data00.txt\nSend '$new' to start recording\n\n> $new\nCreated: data00.txt\n\n> Hello World\n(\u6570\u636e\u5199\u5165SD\u5361)\n\n> $new\nCreated: data01.txt\n```\n\n### \u4e03\u3001CubeMX\u914d\u7f6e\u8981\u70b9\n\n|  \u5916\u8bbe  |               \u914d\u7f6e               |\n| :----: | :------------------------------: |\n|  SPI1  | Full-Duplex Master, \u5206\u9891\u540e\u226418MHz |\n| USART1 |          115200, DMA RX          |\n|  TIM2  |        10ms\u5468\u671f, \u5f00\u542f\u4e2d\u65ad        |\n| FATFS  |           User-defined           |\n\n\n\n\n\n\u3002", "top": 0, "createdAt": 1767517342, "style": "", "script": "", "head": "", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "createdDate": "2026-01-04", "dateLabelColor": "#1f883d"}}, "singeListJson": {}, "labelColorDict": {"bug": "#d73a4a", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "knowledge": "#9ef401", "matlab": "#d93f0b", "question": "#d876e3", "stm32": "#bfd4f2", "wontfix": "#ffffff"}, "displayTitle": "\u56db\u5915\u7684\u535a\u5ba2\u5c0f\u7ad9", "faviconUrl": "https://avatars.githubusercontent.com/u/52995168?v=4", "ogImage": "https://avatars.githubusercontent.com/u/52995168?v=4", "primerCSS": "<link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />", "homeUrl": "https://sixiai.github.io/sixiai.github.io_old", "prevUrl": "disabled", "nextUrl": "disabled"}