<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>四夕的博客小站</title><link>https://sixiai.github.io/sixiai.github.io_old</link><description>一颗快乐码农</description><copyright>四夕的博客小站</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/52995168?v=4</url><title>avatar</title><link>https://sixiai.github.io/sixiai.github.io_old</link></image><lastBuildDate>Sun, 11 Jan 2026 16:12:17 +0000</lastBuildDate><managingEditor>四夕的博客小站</managingEditor><ttl>60</ttl><webMaster>四夕的博客小站</webMaster><item><title>STM32F103C8T6串口黑匣子</title><link>https://sixiai.github.io/sixiai.github.io_old/post/STM32F103C8T6-chuan-kou-hei-xia-zi.html</link><description># SD卡数据记录系统 - 完整总结 

## 一、系统功能

```
┌─────────────────────────────────────────────────────────┐
│  串口发送 '$new' → 新建 data00.txt → 开始记录数据        │
│  串口发送 '$new' → 新建 data01.txt → 继续记录数据        │
│  串口发送 '$new' → 新建 data02.txt → ...                │
│                                                         │
│  定时同步数据到SD卡，防止断电丢失                         │
└─────────────────────────────────────────────────────────┘
```

## 二、文件结构

```
Project/
├── Core/Inc/
│   ├── sd_spi.h			     ← SD初始化驱动
│   ├── uart_driver.h      ← 串口驱动
│   └── sd_logger.h        ← SD记录器
├── Core/Src/
│   ├── main.c             ← 主程序
│   ├── sd_spi.c			     ← SD初始化驱动
│   ├── uart_driver.c      ← 串口驱动
│   ├── sd_logger.c        ← SD记录器
│   └── stm32f1xx_it.c     ← 中断处理
└── FATFS/                 
│   ├── user_diskio.c			 ← FatFs文件系统挂载
```

## 三、核心代码

#### 3.1 sd_spi.h

```c
/* sd_spi.h */
#ifndef __SD_SPI_H
#define __SD_SPI_H

#include 'main.h'
#include 'spi.h'

/* SD卡类型定义 */
#define SD_TYPE_ERR     0x00
#define SD_TYPE_MMC     0x01
#define SD_TYPE_V1      0x02
#define SD_TYPE_V2      0x04
#define SD_TYPE_V2HC    0x06

/* SD卡指令 */
#define CMD0    0       // 复位
#define CMD1    1       // 初始化
#define CMD8    8       // 检查电压范围
#define CMD9    9       // 读CSD
#define CMD10   10      // 读CID
#define CMD12   12      // 停止传输
#define CMD16   16      // 设置块大小
#define CMD17   17      // 读单块
#define CMD18   18      // 读多块
#define CMD23   23      // 预擦除
#define CMD24   24      // 写单块
#define CMD25   25      // 写多块
#define CMD41   41      // 初始化(ACMD)
#define CMD55   55      // APP命令前缀
#define CMD58   58      // 读OCR

/* 函数声明 */
uint8_t SD_Init(void);
uint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);
uint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);
uint32_t SD_GetSectorCount(void);

extern uint8_t SD_Type;

#endif

```

#### 3.2 sd_spi.c

```c
/* sd_spi.c */
#include 'sd_spi.h'

uint8_t SD_Type = 0;

/* CS引脚控制 */
#define SD_CS_LOW()     HAL_GPIO_WritePin(CD_CS_GPIO_Port, CD_CS_Pin, GPIO_PIN_RESET)
#define SD_CS_HIGH()    HAL_GPIO_WritePin(CD_CS_GPIO_Port, CD_CS_Pin, GPIO_PIN_SET)

/* SPI读写一个字节 */
static uint8_t SD_SPI_ReadWriteByte(uint8_t data)
{
    uint8_t rxData;
    HAL_SPI_TransmitReceive(&amp;hspi1, &amp;data, &amp;rxData, 1, 100);
    return rxData;
}

/* 设置SPI速度 */
static void SD_SPI_SetSpeed(uint8_t speed)
{
    __HAL_SPI_DISABLE(&amp;hspi1);
    if(speed == 0) {
        hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; // 低速
    } else {
        hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;   // 高速
    }
    HAL_SPI_Init(&amp;hspi1);
    __HAL_SPI_ENABLE(&amp;hspi1);
}

/* 等待SD卡就绪 */
static uint8_t SD_WaitReady(void)
{
    uint32_t t = 0;
    do {
        if(SD_SPI_ReadWriteByte(0xFF) == 0xFF) return 0;
        t++;
    } while(t &lt; 0xFFFFFF);
    return 1;
}

/* 发送命令 */
static uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg, uint8_t crc)
{
    uint8_t r1;
    uint8_t retry = 0;
    
    SD_CS_HIGH();
    SD_SPI_ReadWriteByte(0xFF);
    SD_CS_LOW();
    
    if(SD_WaitReady()) return 0xFF;
    
    SD_SPI_ReadWriteByte(cmd | 0x40);
    SD_SPI_ReadWriteByte(arg &gt;&gt; 24);
    SD_SPI_ReadWriteByte(arg &gt;&gt; 16);
    SD_SPI_ReadWriteByte(arg &gt;&gt; 8);
    SD_SPI_ReadWriteByte(arg);
    SD_SPI_ReadWriteByte(crc);
    
    if(cmd == CMD12) SD_SPI_ReadWriteByte(0xFF);
    
    retry = 0x1F;
    do {
        r1 = SD_SPI_ReadWriteByte(0xFF);
    } while((r1 &amp; 0x80) &amp;&amp; retry--);
    
    return r1;
}

/* SD卡初始化 */
uint8_t SD_Init(void)
{
    uint8_t r1;
    uint16_t retry;
    uint8_t buf[4];
    
    SD_SPI_SetSpeed(0);  // 低速模式
    
    SD_CS_HIGH();
    for(int i = 0; i &lt; 10; i++) {
        SD_SPI_ReadWriteByte(0xFF);  // 发送至少74个时钟
    }
    
    retry = 20;
    do {
        r1 = SD_SendCmd(CMD0, 0, 0x95);
    } while((r1 != 0x01) &amp;&amp; retry--);
    
    if(r1 == 0x01) {
        if(SD_SendCmd(CMD8, 0x1AA, 0x87) == 1) {
            for(int i = 0; i &lt; 4; i++) {
                buf[i] = SD_SPI_ReadWriteByte(0xFF);
            }
            if(buf[2] == 0x01 &amp;&amp; buf[3] == 0xAA) {
                retry = 0xFFFE;
                do {
                    SD_SendCmd(CMD55, 0, 0x01);
                    r1 = SD_SendCmd(CMD41, 0x40000000, 0x01);
                } while(r1 &amp;&amp; retry--);
                
                if(retry &amp;&amp; SD_SendCmd(CMD58, 0, 0x01) == 0) {
                    for(int i = 0; i &lt; 4; i++) {
                        buf[i] = SD_SPI_ReadWriteByte(0xFF);
                    }
                    if(buf[0] &amp; 0x40) {
                        SD_Type = SD_TYPE_V2HC;
                    } else {
                        SD_Type = SD_TYPE_V2;
                    }
                }
            }
        } else {
            SD_SendCmd(CMD55, 0, 0x01);
            r1 = SD_SendCmd(CMD41, 0, 0x01);
            if(r1 &lt;= 1) {
                SD_Type = SD_TYPE_V1;
                retry = 0xFFFE;
                do {
                    SD_SendCmd(CMD55, 0, 0x01);
                    r1 = SD_SendCmd(CMD41, 0, 0x01);
                } while(r1 &amp;&amp; retry--);
            } else {
                SD_Type = SD_TYPE_MMC;
                retry = 0xFFFE;
                do {
                    r1 = SD_SendCmd(CMD1, 0, 0x01);
                } while(r1 &amp;&amp; retry--);
            }
            if(retry == 0 || SD_SendCmd(CMD16, 512, 0x01) != 0) {
                SD_Type = SD_TYPE_ERR;
            }
        }
    }
    
    SD_CS_HIGH();
    SD_SPI_SetSpeed(1);  // 高速模式
    
    if(SD_Type) return 0;
    return 1;
}

/* 读取指定扇区 */
uint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt)
{
    uint8_t r1;
    
    if(SD_Type != SD_TYPE_V2HC) sector &lt;&lt;= 9;
    
    if(cnt == 1) {
        r1 = SD_SendCmd(CMD17, sector, 0x01);
        if(r1 == 0) {
            uint16_t retry = 0xFFFE;
            do {
                r1 = SD_SPI_ReadWriteByte(0xFF);
                if(r1 == 0xFE) break;
            } while(retry--);
            
            if(r1 == 0xFE) {
                for(int i = 0; i &lt; 512; i++) {
                    buf[i] = SD_SPI_ReadWriteByte(0xFF);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
                r1 = 0;
            } else {
                r1 = 1;
            }
        }
    } else {
        r1 = SD_SendCmd(CMD18, sector, 0x01);
        if(r1 == 0) {
            do {
                uint16_t retry = 0xFFFE;
                do {
                    r1 = SD_SPI_ReadWriteByte(0xFF);
                    if(r1 == 0xFE) break;
                } while(retry--);
                
                if(r1 != 0xFE) break;
                
                for(int i = 0; i &lt; 512; i++) {
                    *buf++ = SD_SPI_ReadWriteByte(0xFF);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
            } while(--cnt);
            SD_SendCmd(CMD12, 0, 0x01);
        }
        r1 = cnt ? 1 : 0;
    }
    
    SD_CS_HIGH();
    return r1;
}

/* 写入指定扇区 */
uint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt)
{
    uint8_t r1;
    
    if(SD_Type != SD_TYPE_V2HC) sector &lt;&lt;= 9;
    
    if(cnt == 1) {
        r1 = SD_SendCmd(CMD24, sector, 0x01);
        if(r1 == 0) {
            if(SD_WaitReady() == 0) {
                SD_SPI_ReadWriteByte(0xFE);
                for(int i = 0; i &lt; 512; i++) {
                    SD_SPI_ReadWriteByte(buf[i]);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
                
                r1 = SD_SPI_ReadWriteByte(0xFF);
                if((r1 &amp; 0x1F) == 0x05) {
                    r1 = 0;
                    uint32_t retry = 0xFFFFFF;
                    while(SD_SPI_ReadWriteByte(0xFF) == 0 &amp;&amp; retry--);
                    if(retry == 0) r1 = 1;
                } else {
                    r1 = 1;
                }
            } else {
                r1 = 1;
            }
        }
    } else {
        if(SD_Type != SD_TYPE_MMC) {
            SD_SendCmd(CMD55, 0, 0x01);
            SD_SendCmd(CMD23, cnt, 0x01);
        }
        r1 = SD_SendCmd(CMD25, sector, 0x01);
        if(r1 == 0) {
            do {
                if(SD_WaitReady()) { r1 = 1; break; }
                SD_SPI_ReadWriteByte(0xFC);
                for(int i = 0; i &lt; 512; i++) {
                    SD_SPI_ReadWriteByte(*buf++);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
                
                r1 = SD_SPI_ReadWriteByte(0xFF);
                if((r1 &amp; 0x1F) != 0x05) { r1 = 1; break; }
            } while(--cnt);
            
            SD_SPI_ReadWriteByte(0xFD);
            r1 = cnt ? 1 : 0;
        }
    }
    
    SD_CS_HIGH();
    return r1;
}

/* 获取扇区数量 */
uint32_t SD_GetSectorCount(void)
{
    uint8_t csd[16];
    uint32_t capacity;
    uint8_t n;
    uint16_t csize;
    
    if(SD_SendCmd(CMD9, 0, 0x01) == 0) {
        uint16_t retry = 0xFFFE;
        while(SD_SPI_ReadWriteByte(0xFF) != 0xFE &amp;&amp; retry--);
        
        if(retry) {
            for(int i = 0; i &lt; 16; i++) {
                csd[i] = SD_SPI_ReadWriteByte(0xFF);
            }
            SD_SPI_ReadWriteByte(0xFF);
            SD_SPI_ReadWriteByte(0xFF);
            
            if((csd[0] &amp; 0xC0) == 0x40) {  // V2.0
                csize = csd[9] + ((uint16_t)csd[8] &lt;&lt; 8) + ((uint32_t)(csd[7] &amp; 0x3F) &lt;&lt; 16) + 1;
                capacity = csize &lt;&lt; 10;
            } else {  // V1.0
                n = (csd[5] &amp; 0x0F) + ((csd[10] &amp; 0x80) &gt;&gt; 7) + ((csd[9] &amp; 0x03) &lt;&lt; 1) + 2;
                csize = (csd[8] &gt;&gt; 6) + ((uint16_t)csd[7] &lt;&lt; 2) + ((uint16_t)(csd[6] &amp; 0x03) &lt;&lt; 10) + 1;
                capacity = (uint32_t)csize &lt;&lt; (n - 9);
            }
            SD_CS_HIGH();
            return capacity;
        }
    }
    SD_CS_HIGH();
    return 0;
}

```

#### 3.3 user_diskio.c

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
  * @file    user_diskio.c
  * @brief   This file includes a diskio driver skeleton to be completed by the user.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
 /* USER CODE END Header */

#ifdef USE_OBSOLETE_USER_CODE_SECTION_0
/*
 * Warning: the user section 0 is no more in use (starting from CubeMx version 4.16.0)
 * To be suppressed in the future.
 * Kept to ensure backward compatibility with previous CubeMx versions when
 * migrating projects.
 * User code previously added there should be copied in the new user sections before
 * the section contents can be deleted.
 */
/* USER CODE BEGIN 0 */
/* USER CODE END 0 */
#endif

/* USER CODE BEGIN DECL */

/* Includes ------------------------------------------------------------------*/
#include &lt;string.h&gt;
#include 'ff_gen_drv.h'


#include 'sd_spi.h'
/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/
/* Disk status */
static volatile DSTATUS Stat = STA_NOINIT;

/* USER CODE END DECL */

/* Private function prototypes -----------------------------------------------*/
DSTATUS USER_initialize (BYTE pdrv);
DSTATUS USER_status (BYTE pdrv);
DRESULT USER_read (BYTE pdrv, BYTE *buff, DWORD sector, UINT count);
#if _USE_WRITE == 1
  DRESULT USER_write (BYTE pdrv, const BYTE *buff, DWORD sector, UINT count);
#endif /* _USE_WRITE == 1 */
#if _USE_IOCTL == 1
  DRESULT USER_ioctl (BYTE pdrv, BYTE cmd, void *buff);
#endif /* _USE_IOCTL == 1 */

Diskio_drvTypeDef  USER_Driver =
{
  USER_initialize,
  USER_status,
  USER_read,
#if  _USE_WRITE
  USER_write,
#endif  /* _USE_WRITE == 1 */
#if  _USE_IOCTL == 1
  USER_ioctl,
#endif /* _USE_IOCTL == 1 */
};

/* Private functions ---------------------------------------------------------*/

/**
  * @brief  Initializes a Drive
  * @param  pdrv: Physical drive number (0..)
  * @retval DSTATUS: Operation status
  */
DSTATUS USER_initialize (
	BYTE pdrv           /* Physical drive nmuber to identify the drive */
)
{
  /* USER CODE BEGIN INIT */
//    Stat = STA_NOINIT;
//    return Stat;
		uint8_t res;
    res = SD_Init();
    if(res == 0) {
        Stat &amp;= ~STA_NOINIT;
    } else {
        Stat = STA_NOINIT;
    }
    return Stat;
  /* USER CODE END INIT */
}

/**
  * @brief  Gets Disk Status
  * @param  pdrv: Physical drive number (0..)
  * @retval DSTATUS: Operation status
  */
DSTATUS USER_status (
	BYTE pdrv       /* Physical drive number to identify the drive */
)
{
  /* USER CODE BEGIN STATUS */
//    Stat = STA_NOINIT;
//    return Stat;
		return Stat;
  /* USER CODE END STATUS */
}

/**
  * @brief  Reads Sector(s)
  * @param  pdrv: Physical drive number (0..)
  * @param  *buff: Data buffer to store read data
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT USER_read (
	BYTE pdrv,      /* Physical drive nmuber to identify the drive */
	BYTE *buff,     /* Data buffer to store read data */
	DWORD sector,   /* Sector address in LBA */
	UINT count      /* Number of sectors to read */
)
{
  /* USER CODE BEGIN READ */
//    return RES_OK;
    uint8_t res;
    res = SD_ReadDisk(buff, sector, count);
    if(res == 0) {
        return RES_OK;
    }
    return RES_ERROR;
  /* USER CODE END READ */
}

/**
  * @brief  Writes Sector(s)
  * @param  pdrv: Physical drive number (0..)
  * @param  *buff: Data to be written
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT USER_write (
	BYTE pdrv,          /* Physical drive nmuber to identify the drive */
	const BYTE *buff,   /* Data to be written */
	DWORD sector,       /* Sector address in LBA */
	UINT count          /* Number of sectors to write */
)
{
  /* USER CODE BEGIN WRITE */
  /* USER CODE HERE */
//    return RES_OK;
    uint8_t res;
    res = SD_WriteDisk((uint8_t *)buff, sector, count);
    if(res == 0) {
        return RES_OK;
    }
    return RES_ERROR;
  /* USER CODE END WRITE */
}
#endif /* _USE_WRITE == 1 */

/**
  * @brief  I/O control operation
  * @param  pdrv: Physical drive number (0..)
  * @param  cmd: Control code
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT USER_ioctl (
	BYTE pdrv,      /* Physical drive nmuber (0..) */
	BYTE cmd,       /* Control code */
	void *buff      /* Buffer to send/receive control data */
)
{
  /* USER CODE BEGIN IOCTL */
//    DRESULT res = RES_ERROR;
//    return res;
    DRESULT res = RES_ERROR;
    
    switch(cmd) {
        case CTRL_SYNC:
            res = RES_OK;
            break;
        case GET_SECTOR_COUNT:
            *(DWORD *)buff = SD_GetSectorCount();
            res = RES_OK;
            break;
        case GET_SECTOR_SIZE:
            *(WORD *)buff = 512;
            res = RES_OK;
            break;
        case GET_BLOCK_SIZE:
            *(DWORD *)buff = 8;
            res = RES_OK;
            break;
        default:
            res = RES_PARERR;
            break;
    }
    return res;
  /* USER CODE END IOCTL */
}
#endif /* _USE_IOCTL == 1 */


```



#### 3.4 uart_driver.h

```c
#ifndef __UART_DRIVER_H
#define __UART_DRIVER_H

#include 'main.h'
#include 'usart.h'
#include 'dma.h'
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define UART_DMA_RX_BUFFER_SIZE     512
#define UART_DATA_BUFFER_SIZE       1024
#define UART_TX_BUFFER_SIZE         256
#define CMD_NEW_FILE                '$new'

typedef enum {
    RX_TYPE_NONE = 0,
    RX_TYPE_CMD_NEW,
    RX_TYPE_DATA
} RxDataType_t;

typedef struct {
    uint8_t     dma_rx_buffer[UART_DMA_RX_BUFFER_SIZE];
    uint8_t     data_buffer[UART_DATA_BUFFER_SIZE];
    char        tx_buffer[UART_TX_BUFFER_SIZE];
    volatile uint16_t   data_len;
    volatile uint8_t    rx_complete;
    RxDataType_t        rx_type;
    UART_HandleTypeDef  *huart;
    DMA_HandleTypeDef   *hdma_rx;
} UART_Driver_t;

extern UART_Driver_t uart1_driver;

void UART_Driver_Init(UART_Driver_t *driver, UART_HandleTypeDef *huart, DMA_HandleTypeDef *hdma_rx);
void UART_Driver_StartReceive(UART_Driver_t *driver);
void UART_Driver_IDLE_Handler(UART_Driver_t *driver);
uint8_t UART_Driver_IsRxComplete(UART_Driver_t *driver);
RxDataType_t UART_Driver_GetRxType(UART_Driver_t *driver);
void UART_Driver_GetData(UART_Driver_t *driver, uint8_t **data, uint16_t *len);
void UART_Driver_ClearRxFlag(UART_Driver_t *driver);
void UART_Driver_Printf(UART_Driver_t *driver, const char *format, ...);

#endif

```

#### 3.5 uart_driver.c

```c
#include 'uart_driver.h'

UART_Driver_t uart1_driver;

static RxDataType_t Parse_RxData(uint8_t *data, uint16_t len)
{
    if(len &gt;= strlen(CMD_NEW_FILE)) {
        if(strncmp((char *)data, CMD_NEW_FILE, strlen(CMD_NEW_FILE)) == 0) {
            return RX_TYPE_CMD_NEW;
        }
    }
    return RX_TYPE_DATA;
}

void UART_Driver_Init(UART_Driver_t *driver, UART_HandleTypeDef *huart, DMA_HandleTypeDef *hdma_rx)
{
    driver-&gt;huart = huart;
    driver-&gt;hdma_rx = hdma_rx;
    memset(driver-&gt;dma_rx_buffer, 0, UART_DMA_RX_BUFFER_SIZE);
    memset(driver-&gt;data_buffer, 0, UART_DATA_BUFFER_SIZE);
    driver-&gt;data_len = 0;
    driver-&gt;rx_complete = 0;
    driver-&gt;rx_type = RX_TYPE_NONE;
}

void UART_Driver_StartReceive(UART_Driver_t *driver)
{
    __HAL_UART_CLEAR_IDLEFLAG(driver-&gt;huart);
    __HAL_UART_ENABLE_IT(driver-&gt;huart, UART_IT_IDLE);
    HAL_UART_Receive_DMA(driver-&gt;huart, driver-&gt;dma_rx_buffer, UART_DMA_RX_BUFFER_SIZE);
}

void UART_Driver_IDLE_Handler(UART_Driver_t *driver)
{
    uint16_t recv_len;
    
    if(__HAL_UART_GET_FLAG(driver-&gt;huart, UART_FLAG_IDLE) != RESET)
    {
        __HAL_UART_CLEAR_IDLEFLAG(driver-&gt;huart);
        HAL_UART_DMAStop(driver-&gt;huart);
        
        recv_len = UART_DMA_RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(driver-&gt;hdma_rx);
        
        if(recv_len &gt; 0 &amp;&amp; recv_len &lt;= UART_DATA_BUFFER_SIZE)
        {
            memcpy(driver-&gt;data_buffer, driver-&gt;dma_rx_buffer, recv_len);
            driver-&gt;data_len = recv_len;
            driver-&gt;rx_type = Parse_RxData(driver-&gt;data_buffer, recv_len);
            driver-&gt;rx_complete = 1;
        }
        
        memset(driver-&gt;dma_rx_buffer, 0, UART_DMA_RX_BUFFER_SIZE);
        HAL_UART_Receive_DMA(driver-&gt;huart, driver-&gt;dma_rx_buffer, UART_DMA_RX_BUFFER_SIZE);
    }
}

uint8_t UART_Driver_IsRxComplete(UART_Driver_t *driver) { return driver-&gt;rx_complete; }
RxDataType_t UART_Driver_GetRxType(UART_Driver_t *driver) { return driver-&gt;rx_type; }

void UART_Driver_GetData(UART_Driver_t *driver, uint8_t **data, uint16_t *len)
{
    *data = driver-&gt;data_buffer;
    *len = driver-&gt;data_len;
}

void UART_Driver_ClearRxFlag(UART_Driver_t *driver)
{
    driver-&gt;rx_complete = 0;
    driver-&gt;data_len = 0;
    driver-&gt;rx_type = RX_TYPE_NONE;
}

void UART_Driver_Printf(UART_Driver_t *driver, const char *format, ...)
{
    uint16_t len;
    va_list args;
    va_start(args, format);
    len = vsprintf(driver-&gt;tx_buffer, format, args);
    va_end(args);
    HAL_UART_Transmit(driver-&gt;huart, (uint8_t *)driver-&gt;tx_buffer, len, 1000);
}

```

#### 3.6 sd_logger.h

```c
#ifndef __SD_LOGGER_H
#define __SD_LOGGER_H

#include 'main.h'
#include 'fatfs.h'
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define FILE_NAME_PREFIX        'data'
#define FILE_NAME_EXTENSION     '.txt'
#define FILE_INDEX_MAX          99
#define SYNC_AFTER_BYTES        512

typedef enum {
    LOGGER_IDLE = 0,
    LOGGER_RECORDING
} LoggerState_t;

typedef struct {
    FATFS       fs;
    FIL         file;
    char        filename[32];
    uint8_t     file_index;
    LoggerState_t state;
    uint8_t     sd_mounted;
    uint32_t    total_bytes;
    uint32_t    unsync_bytes;
} SD_Logger_t;

extern SD_Logger_t sd_logger;

uint8_t SD_Logger_Init(void);
uint8_t SD_Logger_NewFile(void);
uint16_t SD_Logger_WriteData(uint8_t *data, uint16_t len);
uint8_t SD_Logger_Sync(void);
LoggerState_t SD_Logger_GetState(void);
const char* SD_Logger_GetFilename(void);
uint8_t SD_Logger_GetFileIndex(void);
uint32_t SD_Logger_GetTotalBytes(void);

#endif

```

#### 3.7 sd_logger.c

```c
#include 'sd_logger.h'

SD_Logger_t sd_logger;

static void Generate_Filename(uint8_t index, char *filename)
{
    sprintf(filename, '%s%02d%s', FILE_NAME_PREFIX, index, FILE_NAME_EXTENSION);
}

static uint8_t File_Exists(const char *filename)
{
    FILINFO fno;
    return (f_stat(filename, &amp;fno) == FR_OK) ? 1 : 0;
}

static uint8_t Find_Next_FileIndex(void)
{
    char filename[32];
    for(uint8_t i = 0; i &lt;= FILE_INDEX_MAX; i++) {
        Generate_Filename(i, filename);
        if(!File_Exists(filename)) return i;
    }
    return 0;
}

uint8_t SD_Logger_Init(void)
{
    FRESULT fres;
    memset(&amp;sd_logger, 0, sizeof(SD_Logger_t));
    
    fres = f_mount(&amp;sd_logger.fs, '', 1);
    if(fres != FR_OK) return (uint8_t)fres;
    
    sd_logger.sd_mounted = 1;
    sd_logger.file_index = Find_Next_FileIndex();
    return 0;
}

uint8_t SD_Logger_NewFile(void)
{
    FRESULT fres;
    if(!sd_logger.sd_mounted) return 1;
    
    /* 关闭旧文件 */
    if(sd_logger.state == LOGGER_RECORDING) {
        f_sync(&amp;sd_logger.file);
        f_close(&amp;sd_logger.file);
    }
    
    /* 创建新文件 */
    Generate_Filename(sd_logger.file_index, sd_logger.filename);
    fres = f_open(&amp;sd_logger.file, sd_logger.filename, FA_CREATE_ALWAYS | FA_WRITE);
    if(fres != FR_OK) return (uint8_t)fres;
    
    sd_logger.state = LOGGER_RECORDING;
    sd_logger.total_bytes = 0;
    sd_logger.unsync_bytes = 0;
    
    sd_logger.file_index++;
    if(sd_logger.file_index &gt; FILE_INDEX_MAX) sd_logger.file_index = 0;
    
    return 0;
}

uint16_t SD_Logger_WriteData(uint8_t *data, uint16_t len)
{
    UINT bw = 0;
    if(sd_logger.state != LOGGER_RECORDING) return 0;
    
    if(f_write(&amp;sd_logger.file, data, len, &amp;bw) != FR_OK) return 0;
    
    sd_logger.total_bytes += bw;
    sd_logger.unsync_bytes += bw;
    
    /* 自动同步保护 */
    if(sd_logger.unsync_bytes &gt;= SYNC_AFTER_BYTES) {
        f_sync(&amp;sd_logger.file);
        sd_logger.unsync_bytes = 0;
    }
    
    return (uint16_t)bw;
}

uint8_t SD_Logger_Sync(void)
{
    if(sd_logger.state != LOGGER_RECORDING) return 0;
    sd_logger.unsync_bytes = 0;
    return (uint8_t)f_sync(&amp;sd_logger.file);
}

LoggerState_t SD_Logger_GetState(void) { return sd_logger.state; }
const char* SD_Logger_GetFilename(void) { return sd_logger.filename; }
uint8_t SD_Logger_GetFileIndex(void) { return sd_logger.file_index; }
uint32_t SD_Logger_GetTotalBytes(void) { return sd_logger.total_bytes; }

```

#### 3.8 main.c

```c
#include 'main.h'
#include 'dma.h'
#include 'fatfs.h'
#include 'spi.h'
#include 'tim.h'
#include 'usart.h'
#include 'gpio.h'
#include 'uart_driver.h'
#include 'sd_logger.h'

volatile uint8_t tim2_flag = 0;
volatile uint16_t tim2_counter = 0;

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_SPI1_Init();
    MX_TIM2_Init();
    MX_USART1_UART_Init();
    MX_FATFS_Init();
    
    UART_Driver_Init(&amp;uart1_driver, &amp;huart1, &amp;hdma_usart1_rx);
    
    if(SD_Logger_Init() == 0) {
        UART_Driver_Printf(&amp;uart1_driver, 'SD Ready! Next: data%02d.txt\r\n', SD_Logger_GetFileIndex());
    }
    
    UART_Driver_StartReceive(&amp;uart1_driver);
    HAL_TIM_Base_Start_IT(&amp;htim2);
    
    UART_Driver_Printf(&amp;uart1_driver, 'Send '$new' to start recording\r\n');
    
    while(1)
    {
        /* 定时任务 */
        if(tim2_flag)
        {
            tim2_flag = 0;
            
            if(tim2_counter % 100 == 0) {  /* 1秒 */
                HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
            }
            
            if(tim2_counter % 200 == 0) {  /* 2秒同步 */
                if(SD_Logger_GetState() == LOGGER_RECORDING) {
                    SD_Logger_Sync();
                }
            }
            
            if(tim2_counter &gt;= 10000) tim2_counter = 0;
            tim2_counter++;
        }
        
        /* 串口处理 */
        if(UART_Driver_IsRxComplete(&amp;uart1_driver))
        {
            RxDataType_t rx_type = UART_Driver_GetRxType(&amp;uart1_driver);
            
            if(rx_type == RX_TYPE_CMD_NEW) {
                if(SD_Logger_NewFile() == 0) {
                    UART_Driver_Printf(&amp;uart1_driver, 'Created: %s\r\n', SD_Logger_GetFilename());
                }
            }
            else if(rx_type == RX_TYPE_DATA) {
                if(SD_Logger_GetState() == LOGGER_RECORDING) {
                    uint8_t *data; uint16_t len;
                    UART_Driver_GetData(&amp;uart1_driver, &amp;data, &amp;len);
                    SD_Logger_WriteData(data, len);
                }
            }
            
            UART_Driver_ClearRxFlag(&amp;uart1_driver);
        }
    }
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim-&gt;Instance == TIM2) tim2_flag = 1;
}

```

#### 3.9 stm32f1xx_it.c（中断部分）

```c
#include 'uart_driver.h'

void USART1_IRQHandler(void)
{
    UART_Driver_IDLE_Handler(&amp;uart1_driver);
    HAL_UART_IRQHandler(&amp;huart1);
}

```

### 四、断电保护机制

```
┌─────────────────────────────────────────┐
│           双重保护                       │
├─────────────────────────────────────────┤
│ 1. 写入保护: 每512字节自动同步           │
│ 2. 定时保护: 每2秒强制同步               │
├─────────────────────────────────────────┤
│ 断电最大损失: ≤512字节                   │
│ 文件系统风险: 低                         │
└─────────────────────────────────────────┘
```

### 五、使用流程

```
上电 → SD卡初始化 → 等待命令
         ↓
发送 '$new' → 创建 data00.txt → 记录数据
         ↓
发送 '$new' → 关闭旧文件 → 创建 data01.txt
         ↓
      依次递增...
```

### 六、串口测试

```
SD Ready! Next: data00.txt
Send '$new' to start recording

&gt; $new
Created: data00.txt

&gt; Hello World
(数据写入SD卡)

&gt; $new
Created: data01.txt
```

### 七、CubeMX配置要点

|  外设  |               配置               |
| :----: | :------------------------------: |
|  SPI1  | Full-Duplex Master, 分频后≤18MHz |
| USART1 |          115200, DMA RX          |
|  TIM2  |        10ms周期, 开启中断        |
| FATFS  |           User-defined           |





。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/STM32F103C8T6-chuan-kou-hei-xia-zi.html</guid><pubDate>Sun, 04 Jan 2026 09:02:22 +0000</pubDate></item><item><title>STM32H7的ram、rom分区和注意事项</title><link>https://sixiai.github.io/sixiai.github.io_old/post/STM32H7-de-ram%E3%80%81rom-fen-qu-he-zhu-yi-shi-xiang.html</link><description>## 1、STM32H7系列ram的分布
ram（随机存取存储器，random access memory），以STM32H743VIT6为例，为1M RAM+2M Flash的存储空间。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/STM32H7-de-ram%E3%80%81rom-fen-qu-he-zhu-yi-shi-xiang.html</guid><pubDate>Thu, 20 Nov 2025 10:52:39 +0000</pubDate></item><item><title>STM32CubeMX的ADC配置（以H7为例） </title><link>https://sixiai.github.io/sixiai.github.io_old/post/STM32CubeMX-de-ADC-pei-zhi-%EF%BC%88-yi-H7-wei-li-%EF%BC%89%20.html</link><description># STM32CubeMX的ADC配置（以H7为例）



## 1、打开ADC通道

根据自己的IO口，到Analog中选择对应的ADCx和INx;


## 2、ADC时钟配置

首先到**Clock Configuration**里对ADC的时钟进行配置，通常来说为**20~40MHz**之间为好;


## 3、ADC进行初始化配置

&lt;u&gt;***打开Parameter Setting***&lt;/u&gt;

&lt;u&gt;***默认配置需重点选择`Resolution`、`Conversion Data Management Mode`、`External Trigger Conversion Source`、`Rank` 等选项***&lt;/u&gt;

### 3.1  ADCs_Conmon_Setting配置和解释

#### 3.1.1 Mode配置

**推荐设置**：Independent mode
**解释**：H7 里有多个 ADC（ADC1/2/3），可以互相“联机”做多模式采样，你现在只用一个 ADC，就保持独立模式即可。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/STM32CubeMX-de-ADC-pei-zhi-%EF%BC%88-yi-H7-wei-li-%EF%BC%89%20.html</guid><pubDate>Fri, 14 Nov 2025 03:28:15 +0000</pubDate></item><item><title>Matlab中的TCP和串口(uart)服务</title><link>https://sixiai.github.io/sixiai.github.io_old/post/Matlab-zhong-de-TCP-he-chuan-kou-%28uart%29-fu-wu.html</link><description>一个很简单的TCP例子如下：
```
clc; clear; close all;

t = tcpclient('192.168.1.120', 8080, 'Timeout', 5);
PACK = 128;         % 每帧长度
IS_BIG_ENDIAN = false;
sbl_dada = [0,0,0,0,0];
disp('等待二进制帧...');
buf = uint8([]);
i = 0;
a = 1;
h = 1.732;

figure(1)

while true
    n = t.NumBytesAvailable;
    if n &gt; 0
        buf = read(t, n, 'uint8');
    end
    % 够一帧就解析
    while numel(buf) == PACK
        distance1_vals = typecast(buf(45:48), 'single');
        distance2_vals = typecast(buf(49:52), 'single');
        distance3_vals = typecast(buf(53:56), 'single');
        distance = [distance1_vals distance2_vals distance3_vals];
        body_position = distance_calculation_xyz(distance,a,h);
        increase_vals = typecast(buf(117:120), 'single');
        energy_vals = typecast(buf(121:124), 'single');
        sbl_dada = [sbl_dada;distance1_vals distance2_vals distance3_vals increase_vals energy_vals];
        fprintf('distance: %f  %f  %f  %f  %f\n', distance1_vals, distance2_vals, distance3_vals, increase_vals, energy_vals);
        buf = uint8([]);
        i = i + 1;
        subplot(3,2,[1 2]);
        plot(i,distance1_vals,'b.',i,distance2_vals,'g.',i,distance3_vals,'r.');
        hold on
        ylim([11 20])
        grid on
        
        subplot(3,2,3);
        plot(i,increase_vals,'b.');
        ylim([-500 300])
        grid on
        hold on
        subplot(3,2,4);
        plot(i,energy_vals,'b.');
        ylim([0 20000000])
        grid on
        hold on

        subplot(3,2,[5 6]);
        plot(body_position(:,1),body_position(:,2),'r*-')
        grid on
        hold on
    end

    pause(0.005);
end

function body_position = distance_calculation_xyz(distance,a,h)
% 三水听器等边三角形布阵
% 1号水听器位于X轴的正半轴，坐标为(a,0,0)，
% 2号水听器位于Y轴的正半轴，坐标为(0,h,0)，
% 3号水听器位于X轴的负半轴，坐标为(-a,0,0)。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/Matlab-zhong-de-TCP-he-chuan-kou-%28uart%29-fu-wu.html</guid><pubDate>Sat, 08 Nov 2025 08:55:25 +0000</pubDate></item><item><title>认识线性调频信号（LFM）</title><link>https://sixiai.github.io/sixiai.github.io_old/post/ren-shi-xian-xing-diao-pin-xin-hao-%EF%BC%88LFM%EF%BC%89.html</link><description>LFM（线性调频）既可以是实数（真实物理载波）形式，也可以用复数（解析/基带等效）形式表示——取决于你在做什么。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/ren-shi-xian-xing-diao-pin-xin-hao-%EF%BC%88LFM%EF%BC%89.html</guid><pubDate>Fri, 31 Oct 2025 00:59:03 +0000</pubDate></item><item><title>SBL布阵定位原理</title><link>https://sixiai.github.io/sixiai.github.io_old/post/SBL-bu-zhen-ding-wei-yuan-li.html</link><description># 四水听器情况

&lt;img width='343' height='390' alt='Image' src='https://github.com/user-attachments/assets/866ff70c-a416-463e-9515-63093d10345b' /&gt;

如图1所示为SBL的坐标系统，1号水听器位于水听器基阵的原点坐标为(0,0,0)、2号水听器位于x坐标轴上坐标为(A,0,0)、3号水听器位于y坐标轴上坐标为(0,B,0)、4号水听器位于z坐标轴上坐标为(0,0,C)。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/SBL-bu-zhen-ding-wei-yuan-li.html</guid><pubDate>Tue, 28 Oct 2025 03:04:54 +0000</pubDate></item><item><title>STM32的IWDG配置</title><link>https://sixiai.github.io/sixiai.github.io_old/post/STM32-de-IWDG-pei-zhi.html</link><description># STM32cubemx的IWDG配置

&lt;img width='997' height='675' alt='Image' src='https://github.com/user-attachments/assets/835715d8-c220-4ece-aa73-e887d318803b' /&gt;

&lt;img width='1141' height='546' alt='Image' src='https://github.com/user-attachments/assets/9aecc106-45a5-40e1-8c56-ff4fa311fe61' /&gt;

以上述为例：IWDG时钟频率为32 000Hz；
这里超时时间为32*（4095+1）/32000 = 4.096s。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/STM32-de-IWDG-pei-zhi.html</guid><pubDate>Mon, 27 Oct 2025 09:42:37 +0000</pubDate></item><item><title>四夕的博客测试</title><link>https://sixiai.github.io/sixiai.github.io_old/post/si-xi-de-bo-ke-ce-shi.html</link><description># 一级标题
## 二级标题


。</description><guid isPermaLink="true">https://sixiai.github.io/sixiai.github.io_old/post/si-xi-de-bo-ke-ce-shi.html</guid><pubDate>Mon, 27 Oct 2025 09:14:31 +0000</pubDate></item></channel></rss>